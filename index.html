<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="xiaohua,Dong" />










<meta property="og:type" content="website">
<meta property="og:title" content="隔壁董小花同学">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="隔壁董小花同学">
<meta property="article:author" content="xiaohua Dong">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>隔壁董小花同学</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">隔壁董小花同学</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/26/java/hash_map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohua Dong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="隔壁董小花同学">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/26/java/hash_map/" itemprop="url">HashMap原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-26T19:30:53+08:00">
                2019-09-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="HashMap的工作原理"><a href="#HashMap的工作原理" class="headerlink" title="HashMap的工作原理"></a>HashMap的工作原理</h3><ul>
<li>HashMap的工作原理？（基于hashing，bucket中存储键值对）<br>HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。</li>
<li>当两个对象的hashCode相同会发生什么？（hashCode()和equals()方法）<br>它们会储存在同一个bucket位置的链表中。键对象的equals()方法用来找到键值对。<br>注：首先，hashCode相同，但equals不一定相等，因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。</li>
<li>如果两个键的hashcode相同，如何获取值对象？（HashMap在链表中存储的是键值对）<br>当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点。<br>使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。</li>
<li>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？（HashMap负载因子0.75）<br>默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。</li>
<li>重新调整HashMap大小存在什么问题吗？（多线程的情况下，可能产生条件竞争(race condition)）<br>如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。（多线程不适用HashMap）</li>
<li>为什么String, Interger这样的wrapper类适合作为键<br>String最为常用。因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。</li>
<li>我们可以使用CocurrentHashMap来代替Hashtable吗？（Hashtable是synchronized的）<br>ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。</li>
</ul>
<h3 id="HashCode与equals"><a href="#HashCode与equals" class="headerlink" title="HashCode与equals"></a>HashCode与equals</h3><ul>
<li>就是hashCode是用于查找使用的，而equals是用于比较两个对象的是否相等的<h4 id="HashCode"><a href="#HashCode" class="headerlink" title="HashCode"></a>HashCode</h4></li>
</ul>
<ol>
<li>shCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的</li>
<li>如果两个对象相同，就是适用于equals(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同。</li>
<li>如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点。</li>
<li>两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里“。<h4 id="Equals"><a href="#Equals" class="headerlink" title="Equals"></a>Equals</h4></li>
<li>equals和==<br>==用于比较引用和比较基本数据类型时具有不同的功能：<br>比较基本数据类型，如果两个值相同，则结果为true<br>而在比较引用时，如果引用指向内存中的同一对象，结果为true;<br>equals()作为方法，实现对象的比较。由于==运算符不允许我们进行覆盖，也就是说它限制了我们的表达。因此我们复写equals()方法，达到比较对象内容是否相同的目的。而这些通过==运算符是做不到的。</li>
<li>object类的equals()方法的比较规则为：<br>如果两个对象的类型一致，并且内容一致，则返回true,这些类有：<br>java.io.file,java.util.Date,java.lang.string,包装类（Integer,Double等）<br>String s1=new String(“abc”);<br>String s2=new String(“abc”);<br>System.out.println(s1==s2);<br>System.out.println(s1.equals(s2));<br>运行结果为false true  </li>
</ol>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p> HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。<br> 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。  </p>
<h4 id="HashMap的存取"><a href="#HashMap的存取" class="headerlink" title="HashMap的存取"></a>HashMap的存取</h4><p>根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。<br>hash(int h)方法根据key的hashCode重新计算一次散列。此算法加入了高位计算，防止低位不变，高位变化时，造成的hash冲突。  </p>
<ol>
<li>存储<br>当程序试图将一个key-value对放入HashMap中时，程序首先根据该 key的 hashCode() 返回值决定该 Entry 的存储位置：如果两个 Entry 的 key 的 hashCode() 返回值相同，那它们的存储位置相同。如果这两个 Entry 的 key 通过 equals 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有 Entry的 value，但key不会覆盖。如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的 Entry 位于 Entry 链的头部——具体说明继续看 addEntry() 方法的说明。  </li>
<li>读取<br>从HashMap中get元素时，首先计算key的hashCode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。  <ul>
<li>总结：HashMap 在底层将 key-value 当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个 Entry[] 数组来保存所有的 key-value 对，当需要存储一个 Entry 对象时，会根据hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry  <h4 id="HashMap的resize"><a href="#HashMap的resize" class="headerlink" title="HashMap的resize"></a>HashMap的resize</h4>当hashmap中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对hashmap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，所以这是一个通用的操作，很多人对它的性能表示过怀疑，不过想想我们的“均摊”原理，就释然了，而在hashmap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。<br>那么hashmap什么时候进行扩容呢？当hashmap中的元素个数超过数组大小<em>loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16</em>0.75=12的时候，就把数组的大小扩展为2<em>16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过上面annegu已经说过，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.75</em>1000 &lt; 1000, 也就是说为了让0.75 * size &gt; 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了&amp;的问题，也避免了resize的问题。</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>HashMap的实现原理：<br>利用key的hashCode重新hash计算出当前对象的元素在数组中的下标<br>存储时，如果出现hash值相同的key，此时有两种情况。(1)如果key相同，则覆盖原始值；(2)如果key不同（出现冲突），则将当前的key-value放入链表中<br>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。<br>理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。  </p>
<blockquote>
<p>借鉴：<a href="https://www.cnblogs.com/yuanblog/p/4441017.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuanblog/p/4441017.html</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/26/database/mybatis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohua Dong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="隔壁董小花同学">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/26/database/mybatis/" itemprop="url">Mybatis的缓存机制及其作用的原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-26T19:30:14+08:00">
                2019-09-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/database/" itemprop="url" rel="index">
                    <span itemprop="name">database</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Mybatis缓存机制"><a href="#Mybatis缓存机制" class="headerlink" title="Mybatis缓存机制"></a>Mybatis缓存机制</h3><p>mybatis提供了缓存机制减轻数据库压力，提高数据库性能<br>mybatis的缓存分为两级：一级缓存、二级缓存<br>一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效<br>二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的  </p>
<h4 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h4><p>mybatis的一级缓存是SqlSession级别的缓存，在操作数据库的时候需要先创建SqlSession会话对象，在对象中有一个HashMap用于存储缓存数据，此HashMap是当前会话对象私有的，别的SqlSession会话对象无法访问。<br>当一个sqlSession结束后该sqlSession中的一级缓存也就不存在了。(PerpetualCache) </p>
<ul>
<li>具体流程：</li>
</ul>
<ol>
<li>第一次执行select完毕会将查到的数据写入SqlSession内的HashMap中缓存起来</li>
<li>第二次执行select会从缓存中查数据，如果select相同切传参数一样，那么就能从缓存中返回数据，不用去数据库了，从而提高了效率</li>
</ol>
<ul>
<li>注意：</li>
</ul>
<ol>
<li>如果SqlSession执行了DML操作（insert、update、delete），并commit了，那么mybatis就会清空当前SqlSession缓存中的所有缓存数据，这样可以保证缓存中的存的数据永远和数据库中一致，避免出现脏读</li>
<li>当一个SqlSession结束后那么他里面的一级缓存也就不存在了，mybatis默认是开启一级缓存，不需要配置</li>
<li>mybatis的缓存是基于[namespace:sql语句:参数]来进行缓存的，意思就是，SqlSession的HashMap存储缓存数据时，是使用[namespace:sql:参数]作为key，查询返回的语句作为value保存的。例如：-1242243203:1146242777:winclpt.bean.userMapper.getUser:0:2147483647:select * from user where id=?:19</li>
</ol>
<h4 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h4><p>二级缓存是mapper级别的缓存，也就是同一个namespace的mappe.xml，当多个SqlSession使用同一个Mapper操作数据库的时候，得到的数据会缓存在同一个二级缓存区域<br>二级缓存它有数据的多session共享机制，但是呢，会导致user在两个命名空间下的数据不一致。<br>二级缓存默认是没有开启的。需要在setting全局参数中配置开启二级缓存。</p>
<ol>
<li>conf.xml：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">        &lt;setting name&#x3D;&quot;cacheEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;默认是false：关闭二级缓存</span><br><span class="line">&lt;settings&gt;</span><br></pre></td></tr></table></figure></li>
<li>mapper.xml<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;cache eviction&#x3D;&quot;LRU&quot; flushInterval&#x3D;&quot;60000&quot; size&#x3D;&quot;512&quot; readOnly&#x3D;&quot;true&quot;&#x2F;&gt;当前mapper下所有语句开启二级缓存</span><br></pre></td></tr></table></figure>
这里配置了一个LRU缓存，并每隔60秒刷新，最大存储512个对象，而却返回的对象是只读的<br>若想禁用当前select语句的二级缓存，添加useCache=”false”修改如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;getCountByName&quot; parameterType&#x3D;&quot;java.util.Map&quot; resultType&#x3D;&quot;INTEGER&quot; statementType&#x3D;&quot;CALLABLE&quot; useCache&#x3D;&quot;false&quot;&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>具体流程：  </li>
</ul>
<ol>
<li>当一个sqlseesion执行了一次select后，在关闭此session的时候，会将查询结果缓存到二级缓存  </li>
<li>当另一个sqlsession执行select时，首先会在他自己的一级缓存中找，如果没找到，就回去二级缓存中找，找到了就返回，就不用去数据库了，从而减少了数据库压力提高了性能  </li>
</ol>
<blockquote>
<p>学习：<a href="https://www.cnblogs.com/winclpt/articles/7511672.html" target="_blank" rel="noopener">https://www.cnblogs.com/winclpt/articles/7511672.html</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/31/http/time_wait/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohua Dong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="隔壁董小花同学">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/31/http/time_wait/" itemprop="url">TIME_WAIT状态分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-31T10:39:04+08:00">
                2019-07-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/http/" itemprop="url" rel="index">
                    <span itemprop="name">http</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="TCP三次握手四次挥手"><a href="#TCP三次握手四次挥手" class="headerlink" title="TCP三次握手四次挥手"></a>TCP三次握手四次挥手</h3><h4 id="三次握手-（建立连接协议）"><a href="#三次握手-（建立连接协议）" class="headerlink" title="三次握手 （建立连接协议）"></a>三次握手 （建立连接协议）</h4><ul>
<li>第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</li>
<li>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。</li>
<li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。  <blockquote>
<p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP连接都将被一直保持下去。  </p>
</blockquote>
</li>
</ul>
<h4 id="四次挥手（连接终止协议）"><a href="#四次挥手（连接终止协议）" class="headerlink" title="四次挥手（连接终止协议）"></a>四次挥手（连接终止协议）</h4><ul>
<li>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可以接受数据。主动方处于FIN_WAIT_1状态</li>
<li>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号， SYN 和 FIN 都有seq序号）。主动方处于FIN_WAIT_2状态</li>
<li>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。被动房处于LAST_ACK状态</li>
<li>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，主动方此时处于TIME_WAIT状态，被动方收到ACK报文后关闭连接，至此，完成四次挥手。  <blockquote>
<p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>
</blockquote>
</li>
</ul>
<h4 id="状态解释"><a href="#状态解释" class="headerlink" title="状态解释"></a>状态解释</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CLOSED：无连接是活动的或正在进行</span><br><span class="line">LISTEN：服务器在等待进入呼叫</span><br><span class="line">SYN_RECV：一个连接请求已经到达，等待确认</span><br><span class="line">SYN_SENT：应用已经开始，打开一个连接</span><br><span class="line">ESTABLISHED：正常数据传输状态</span><br><span class="line">FIN_WAIT1：应用说它已经完成</span><br><span class="line">FIN_WAIT2：另一边已同意释放</span><br><span class="line">ITMED_WAIT：等待所有分组死掉</span><br><span class="line">CLOSING：两边同时尝试关闭</span><br><span class="line">TIME_WAIT：另一边已初始化一个释放</span><br><span class="line">LAST_ACK：等待所有分组死掉</span><br></pre></td></tr></table></figure>

<h4 id="TIME-WAIT过多问题原因及解决（Cannot-assign-requested-address）"><a href="#TIME-WAIT过多问题原因及解决（Cannot-assign-requested-address）" class="headerlink" title="TIME_WAIT过多问题原因及解决（Cannot assign requested address）"></a>TIME_WAIT过多问题原因及解决（Cannot assign requested address）</h4><ul>
<li><p>什么时候会出现TIME_WAIT<br>TCP在关闭的时候有个四次挥手的过程，主动关闭方在四次挥手的最后一个ACK发送之后会变成TIME_WAIT状态。</p>
</li>
<li><p>TIME_WAIT状态维持多久<br>主动关闭方响应完最后一次ACK之后，会在TIME_WAIT这个状态维持2MSL</p>
</li>
<li><p>MSL<br>MSL全称是maximum segment lifetime，最长分节生命期。MSL是任何IP数据报能够在因特网存活的最长时间。我们知道，这个时间是有限的，因为每个数据报都含有一个限跳（hop limit）的8位字段，它的最大值是255（简单的讲就是不同经过超过255个路由器）。尽管这个跳数限制而不是真正的时间限制，我们仍然假设最大限跳的分组在网络中存在的时间不可能超过MSL秒。</p>
</li>
<li><p>TIME_WAIT的作用<br>1）可靠地实现TCP全双工连接的终止<br> 在进行关闭连接四次挥手协议时，最后的ACK是由主动关闭端发出的，如果这个最终的ACK丢失，服务器将重发最终的FIN，<br>因此客户端必须维护状态信息允许它重发最终的ACK。如果不维持这个状态信息，那么客户端将响应RST分节，服务器将此分节解释成一个错误（在java中会抛出connection reset的SocketException)。<br>因而，要实现TCP全双工连接的正常终止，必须处理终止序列四个分节中任何一个分节的丢失情况，主动关闭的客户端必须维持状态信息进入TIME_WAIT状态。<br>2）允许老的重复分节在网络中消逝<br>TCP分节可能由于路由器异常而“迷途”，在迷途期间，TCP发送端可能因确认超时而重发这个分节，迷途的分节在路由器修复后也会被送到最终目的地，这个原来的迷途分节就称为lost duplicate。<br>在关闭一个TCP连接后，马上又重新建立起一个相同的IP地址和端口之间的TCP连接，后一个连接被称为前一个连接的化身（incarnation)，那么有可能出现这种情况，前一个连接的迷途重复分组在前一个连接终止后出现，从而被误解成从属于新的化身。<br>为了避免这个情况，TCP不允许处于TIME_WAIT状态的连接启动一个新的化身，因为TIME_WAIT状态持续2MSL，就可以保证当成功建立一个TCP连接的时候，来自连接先前化身的重复分组已经在网络中消逝。  </p>
</li>
<li><p>大量TIME_WAIT造成的影响<br>在高并发短连接的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量socket处于TIME_WAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。<br>主动正常关闭TCP连接，都会出现TIMEWAIT。<br>为什么我们要关注这个高并发短连接呢？有两个方面需要注意：</p>
</li>
</ul>
<ol>
<li>高并发可以让主动方（大部分是客户端）在短时间范围内同时占用大量端口，而端口有个0~65535的范围，并不是很多，刨除系统和其他服务要用的，剩下的就更少了。（服务端端口是复用的）</li>
<li>在这个场景中，短连接表示“业务处理+传输数据的时间 远远小于 TIMEWAIT超时的时间”的连接。<br>例如： 取一个web页面，1秒钟的http短连接处理完业务，在关闭连接之后，这个业务用过的端口会停留在TIMEWAIT状态几分钟，而这几分钟，其他HTTP请求来临的时候是无法占用此端口的(占着茅坑不拉翔)。单用这个业务计算服务器的利用率会发现，服务器干正经事的时间和端口（资源）被挂着无法被使用的时间的比例是 1：几百，服务器资源严重浪费。（说个题外话，从这个意义出发来考虑服务器性能调优的话，长连接业务的服务就不需要考虑TIMEWAIT状态。同时，假如你对服务器业务场景非常熟悉，你会发现，在实际业务场景中，一般长连接对应的业务的并发量并不会很高。  </li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/19/database/redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohua Dong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="隔壁董小花同学">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/19/database/redis/" itemprop="url">Redis</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-19T16:08:37+08:00">
                2019-07-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h3><ul>
<li>连接  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h host -p post -a pwd</span><br></pre></td></tr></table></figure>
<h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4></li>
<li>info – 查看信息</li>
<li>select [num] – 选择index</li>
<li>keys * – 查看所有key</li>
<li>SET key value – 设置指定 key 的值</li>
<li>GET key – 获取指定 key 的值</li>
<li>GETSET key value – 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</li>
<li>MGET key1 [key2..] – 获取所有(一个或多个)给定 key 的值。</li>
<li>SETEX key seconds value – 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。</li>
<li>PSETEX key milliseconds value – 以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。</li>
<li>SETNX key value – 只有在 key 不存在时设置 key 的值。</li>
<li>MSET key value [key value …] – 同时设置一个或多个 key-value 对。</li>
<li>APPEND key value – 如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。  </li>
<li>DEL key – 该命令用于在 key 存在时删除 key。</li>
<li>EXISTS key – 检查给定 key 是否存在。</li>
<li>DUMP key – 序列化给定 key ，并返回被序列化的值</li>
<li>PERSIST key – 移除 key 的过期时间，key 将持久保持。</li>
<li>PTTL key – 以毫秒为单位返回 key 的剩余的过期时间</li>
<li>RANDOMKEY – 从当前数据库中随机返回一个 key</li>
<li>RENAME key newkey – 修改 key 的名称</li>
<li>RENAMENX key newkey – 仅当 newkey 不存在时，将 key 改名为 newkey</li>
<li>TYPE key – 返回 key 所储存的值的类型</li>
</ul>
<h4 id="pub-发布-sub-订阅"><a href="#pub-发布-sub-订阅" class="headerlink" title="pub(发布) - sub(订阅)"></a>pub(发布) - sub(订阅)</h4><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。<br>Redis 客户端可以订阅任意数量的频道  </p>
<h4 id="列表（List）"><a href="#列表（List）" class="headerlink" title="列表（List）"></a>列表（List）</h4><ul>
<li>LLEN key  获取列表长度</li>
<li>LPOP key  移除并获取列表第一个元素</li>
<li>RPOP key  移除并获取列表最后一个元素</li>
<li>LREM key count value  移除列表元素</li>
<li>RPUSHX key value  对已存在的列表添加元素</li>
<li>LPUSHX key value  将元素插入已存在列表头部</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/21/java/grpc_java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohua Dong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="隔壁董小花同学">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/21/java/grpc_java/" itemprop="url">GRPC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-21T11:36:57+08:00">
                2018-12-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="官方文档：http-grpc-mydoc-io"><a href="#官方文档：http-grpc-mydoc-io" class="headerlink" title="官方文档：http://grpc.mydoc.io/"></a>官方文档：<a href="http://grpc.mydoc.io/" target="_blank" rel="noopener">http://grpc.mydoc.io/</a></h4><h3 id="proto文件："><a href="#proto文件：" class="headerlink" title="proto文件："></a>proto文件：</h3><pre>
syntax = "proto3";

//以外部类模式生成
option java_multiple_files = true;
//所在包名
option java_package = "cn.dxh.practice";
//最外层类名称
option java_outer_classname = "PracticeService";

// 定义服务
service UserService {
    //按id查询数据
    rpc FindById (FindByIdRequest) returns (FindByIdResponse) {
    }

    //服务器端流式 RPC
    //    客户端发送一个请求给服务端，可获取一个数据流用来读取一系列消息。客户端从返回的数据流里一直读取直到没有更多消息为止。
    //    通过在 响应 类型前插入 stream 关键字，可以指定一个服务器端的流方法。
    //查询所有符合条件的数据
    rpc FindByAge (FindByAgeRequest) returns (stream UserEntity) {
    }

    //客户端流式 RPC
    //    即客户端用提供的一个数据流写入并发送一系列消息给服务端。
    //    客户端写入一个消息序列并将其发送到服务器，同样也是使用流。一旦客户端完成消息写入，就等待服务端读取这些消息并返回应答。
    //    通过在 请求 类型前指定 stream 关键字来指定一个客户端的流方法。
    //删除数据
    rpc DeleteById (DeletedByIdRequest) returns (DeletedByIdResponse) {
    }

    //双向流式 RPC
    //    即两边都可以分别通过一个读写数据流来发送一系列消息。这两个数据流操作是相互独立的，所以客户端和服务端能按其希望的任意顺序读写，
    //    例如：服务端可以在写应答前等待所有的客户端消息，或者它可以先读一个消息再写一个消息，或者是读写相结合的其他方式。每个数据流里消息的顺序会被保持。
    //通过在请求和响应前加 stream 关键字去制定方法的类型。
    rpc FindByName (stream FindByNameRequest) returns (stream UserEntity) {
    }
}

//按id查询数据参数
message FindByIdRequest {
    int64 id = 1;
}
//按id查询数据返回结果
message FindByIdResponse {
    string name = 2;
    int32 age = 3;
}
//查询语句的条件参数
message FindByAgeRequest {
    int32 age = 1;
}

//删除数据的参数
message DeletedByIdRequest {
    int64 id = 1;
}

//删除数据的返回结果
message DeletedByIdResponse {
}

//参数
message FindByNameRequest {
}

//实例
message UserEntity {
    int64 id = 1;
    string name = 2;
    int32 age = 3;
    string from = 4;
    string pwd = 5;
}

</pre>

<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><h4 id="编写serviceImpl类"><a href="#编写serviceImpl类" class="headerlink" title="编写serviceImpl类"></a>编写serviceImpl类</h4><p> 此类需要继承 UserServiceGrpc.UserServiceImplBase ,这个类提供了我们定义的接口，继承后并覆盖需要实现的方法。</p>
<pre>
@Slf4j
@Service
public class UserServiceImpl extends UserServiceGrpc.UserServiceImplBase {

  @Resource
  private UserMapper userMapper;

  /**
   * 简单rpc
   * 其中StreamObserver<UserEntity>是一个应答观察者,用于封装返回的信息,服务器把该信息传给客户端.请求结束要调用onCompleted()方法.
   * @param request
   * @param responseObserver
   */
  @Override
  public void findById(FindByIdRequest request, StreamObserver<UserEntity> responseObserver) {
    try {
      long id = request.getId();
      userMapper.findById(id)
      responseObserver.onNext(UserEntity.newBuilder().build());
//      请求结束
      responseObserver.onCompleted();
    } catch (Exception e) {
      log.error("findById is error");
    }
  }

  /**
   * 服务器端流式 RPC
   *
   * @param request
   * @param responseObserver
   */
  @Override
  public void findByAge(FindByAgeRequest request, StreamObserver<UserEntity> responseObserver) {
    try {
      int age = request.getAge();
      List<UserEntity> userEntities = userMapper.findByAgs(age);
      userEntities.forEach(userEntity -> responseObserver.onNext(UserEntity.newBuilder().build()));
      responseObserver.onCompleted();
    } catch (Exception e) {
      log.error("");
    }
  }


  /**
   * 客户端流式 RPC
   * 服务端就需要一直监控客户端写入情况,因此需要一个StreamObserver接口,其中onNext方法会在客户端每次写入时调用,当写入完毕时调用onCompleted()方法
   * @param responseObserver
   * @return
   */
  @Override
  public StreamObserver<DeletedByIdRequest> deleteById(StreamObserver<DeletedByIdResponse> responseObserver) {
    return new StreamObserver<DeletedByIdRequest>() {
      @Override
      public void onNext(DeletedByIdRequest deletedByIdRequest) {
        userMapper.deletedById(deletedByIdRequest.getId());
      }

      @Override
      public void onError(Throwable throwable) {
        throwable.printStackTrace();
      }

      @Override
      public void onCompleted() {
        responseObserver.onNext(DeletedByIdResponse.newBuilder().build());
        responseObserver.onCompleted();
      }
    };
  }

  /**
   * 双向流式 RPC
   *
   * @param responseObserver
   * @return
   */
  @Override
  public StreamObserver<FindByNameRequest> findByName(StreamObserver<UserEntity> responseObserver) {
    return new StreamObserver<FindByNameRequest>() {
      @Override
      public void onNext(FindByNameRequest findByNameRequest) {
        userMapper.findByName(findByNameRequest.getName());
      }

      @Override
      public void onError(Throwable throwable) {
        throwable.printStackTrace();
      }

      @Override
      public void onCompleted() {
        responseObserver.onNext(UserEntity.newBuilder().build());
        responseObserver.onCompleted();
      }
    };
  }
}
</pre>

<h4 id="创建服务端"><a href="#创建服务端" class="headerlink" title="创建服务端"></a>创建服务端</h4><pre>
@Component
public class GrpcService {

  private int port = 19090;
  private Server server;

  @Resource
  private UserServiceGrpc.UserServiceImplBase userService;

  @PostConstruct
  public void init() throws IOException {
    ThreadFactory threadFactory = new ThreadFactoryBuilder().setDaemon(true)
                                                            .setNameFormat("grpc-server-thread-%d")
                                                            .build();
    ThreadPoolExecutor executor = new ThreadPoolExecutor(10,
                                                         100,
                                                         60L,
                                                         TimeUnit.SECONDS,
                                                         new LinkedBlockingQueue<>(),
                                                         threadFactory,
                                                         new ThreadPoolExecutor.CallerRunsPolicy());
    server = ServerBuilder.forPort(port)
                          .addService(userService)
                          .executor(executor).build();
    server.start();
  }

  @PreDestroy
  public void destroy() {
    if (server != null) {
      server.shutdown();
    }
  }

}
</pre>

<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/21/database/postgresql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohua Dong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="隔壁董小花同学">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/21/database/postgresql/" itemprop="url">PostgreSql</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-21T11:36:10+08:00">
                2018-12-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="psql常用命令"><a href="#psql常用命令" class="headerlink" title="psql常用命令"></a>psql常用命令</h3><h5 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h5><p>psql -h [ip] -U [username] -d [databases]</p>
<ul>
<li>创建schema<br>CREATE SCHEMA my_schema;<br>GRANT ALL ON SCHEMA my_schema TO my_user;</li>
<li>查看当前schema<br>SHOW search_path;</li>
<li>查询数据库下所有schema<br>select * from information_schema.schemata;</li>
<li>查询指定schema下所有表<br>select * from information_schema.tables where table_schema=’audit’;</li>
<li>切换schema（连接级）<br>set search_path to my_schema;</li>
<li>改变默认schema（数据库级）<br>ALTER database “my_database” SET search_path TO my_schema;</li>
<li>指定schema查询<br>select count(*) from audit.fxk_pg_oplog;</li>
</ul>
<h3 id="pg基础知识与基本操作"><a href="#pg基础知识与基本操作" class="headerlink" title="pg基础知识与基本操作"></a>pg基础知识与基本操作</h3><p><span style="color:red">查询pg库的所有表名称</span><br>select tablename from pg_tables where schemaname=’public’;<br><span style="color:red">获取pg表的字段</span><br>select column_name from information_schema.columns<br>where table_name = ‘db_job’;</p>
<p><span style="color:red">–查看当前活动的客户端连接数</span><br> SELECT count(*) FROM pg_stat_activity WHERE NOT pid=pg_backend_pid();<br><span style="color:red">–查看PostgreSQL正在执行的SQL</span><br>SELECT<br>    procpid,<br>    start,<br>    now() - start AS lap,<br>    current_query<br>FROM<br>    (SELECT<br>        backendid,<br>        pg_stat_get_backend_pid(S.backendid) AS procpid,<br>        pg_stat_get_backend_activity_start(S.backendid) AS start,<br>       pg_stat_get_backend_activity(S.backendid) AS current_query<br>    FROM<br>        (SELECT pg_stat_get_backend_idset() AS backendid) AS S<br>    ) AS S ,pg_stat_activity pa<br>WHERE<br>   current_query &lt;&gt; ‘<IDLE>‘ and  procpid&lt;&gt; pg_backend_pid() and pa.pid=s.procpid and pa.state&lt;&gt;’idle’<br>ORDER BY<br>   lap DESC;<br><span style="color:red">–查看当前库表和索引的的大小并排序显示前20条</span><br>SELECT<br>nspname,<br>relname,<br>relkind as “type”,<br>pg_size_pretty(pg_table_size(C.oid)) AS size,<br>pg_size_pretty(pg_indexes_size(C.oid)) AS idxsize,<br>pg_size_pretty(pg_total_relation_size(C.oid)) as “total”<br>FROM pg_class C<br>LEFT JOIN pg_namespace N ON (N.oid = C.relnamespace)<br>WHERE nspname NOT IN (‘pg_catalog’, ‘information_schema’) AND<br>nspname !~ ‘^pg_toast’ AND<br>relkind IN (‘r’,’i’)<br>ORDER BY pg_total_relation_size(C.oid) DESC<br>LIMIT 20; </p>
<span style="color:blue">
procpid：进程id  
start：进程开始时间  
lap：经过时间  
current_query：执行中的sql  
怎样停止正在执行的sql  
SELECT pg_cancel_backend(进程id);  
或者用系统函数  
kill -9 进程id;
--查找是否有waiting  
ps -ef|grep postgres | grep wait
</span>

<p>排序：ORDER BY 字段 DESC<br><span style="color:red">模糊不区分大小写查询：</span>UPPER(字段) LIKE UPPER(‘%${search}%’)<br><span style="color:red">查指定条数：</span>LIMIT 长度 OFFSET 起始位置</p>
<p>关联查询：<br>SELECT fail_count<br>FROM test_report AS  f<br>INNER JOIN(SELECT MAX(id) AS b_id FROM test_build WHERE job_id = #{jobId})  r<br>ON f.build_id = r.b_id</p>
<p><span style="color:red">去重返回</span><br>SELECT <span style="color:red">DISTINCT</span><br>    T.parent_id<br>FROM<br>    db_task AS T<br>INNER JOIN db_job AS j ON T.status IN (<br>    ‘running’,<br>    ‘initComplete’,<br>    ‘fail’<br>)<br>AND j.status IN (‘created’, ‘dispatched’)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/11/java/aop_audit_log_java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohua Dong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="隔壁董小花同学">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/11/java/aop_audit_log_java/" itemprop="url">AOP(审计日志的开发与延伸)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-11T19:27:42+08:00">
                2018-12-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解 Annotation"></a>注解 Annotation</h3><p>Annotation其实是代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取，并执行相应的处理。通过使用Annotation，程序开发人员可以在不改变原有逻辑的情况下，在源文件嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。<br></p>
<p>　　Annotation提供了一条为程序元素设置元数据的方法，从某些方面来看，Annotation就像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明，这些信息被存储在Annotation的“name=value”对中。<br></p>
<p>　　Annotation能被用来为程序元素(类、方法、成员变量等)设置元数据。值得指出的是：Annotation不能影响程序代码的执行，无论增加、删除Annotation，代码都始终如一地执行。如果希望让程序中的Annotation能在运行时起一定的作用，只有通过某种配套的工具对Annotation中的信息进行访问的处理，访问和处理Annotation的工具统称APT（Annotation Processing Tool） <br><br><br>Annotation必须使用工具来处理，工具负责提取Annotation里包含的元数据，工具还会根据这些元数据增加额外的功能。<br><br>三个基本的Annotation：<br><br>@Override         限定重写父类的方法<br><br>@Deprecated     标示已过时<br><br>@SuppressWarnings     抑制编译器警告<br></p>
<p><b>自定义Annotation</b><br>定义新的Annotation类型使用@interface关键字，它用于定义新的Annotation类型。定义一个新的Annotation类型与定义一个接口非常像<br><br>定义一个简单的注解：</p>
<pre>
public @interface GetLog {
}
</pre>
<p>带成员变量的Annotation，Annotation的成员变量在Annotation定义中以无参数方法的形式声明。其方法名和返回值定义了该成员的名字和类型<br><br>同时使用时也要指定相应的变量值</p>
<pre>
public @interface GetLog {
    //定义成员变量
    String name();
}

@GetLog(name = "log")
public void getName(){}
</pre>
<p>我们还可以在定义Annotation的成员变量时为其指定初始值，指定成员变量的初始值可使用default关键字;</p>
<pre>
public @interface GetLog {
    //定义成员变量
    String description() default "${description}";
}
</pre>

<p>根据我们介绍的Annotation是否可以包含成员变量，我们可以把Annotation分为如下两类：<br><br>标记Annotation： 一个没有成员定义的Annotation类型被称为标记。这种Annotation仅使用自身的存在与否来为我们提供信息。如前面介绍的@Override。<br><br>元数据Annotation：那些包含成员变量的Annotation，因为它们可接受更多元数据，所以也被称为元数据Annotation。<br></p>
<p><b>提取Annotation信息</b><br>Java使用Annotation接口来代表程序元素前面的注释（反射的时候用它来接收注解对象），该接口是所有Annotation类型的父接口;<br><br>Java在java.lang.reflect包下新增了AnnotateElement接口，该接口代表程序中可以接受注释的程序元素，该接口主要有如下几个实现类（注意以下是类: <br><br>Class：类定义。<br><br>Constructor：构造器定义。<br><br>Field：类的成员变量定义。<br><br>Method：类的方法定义。<br><br>Package：类的包定义。<br><br>java.lang.reflect包下主要包含一些实现反射功能工具类，实际上，java.lang.reflect包提供的反射API扩充了读取运行时Annotation的能力。当一个Annotation类型被定义为运行时Annotation后，该注解才是运行时可见，当class文件被装载时被保存在class文件中的Annotation才会被虚拟机读取。<br><br>AnnotatedElement接口是所有程序元素（如Class、Method、Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象（如Class、Method、Constructor）之后，程序就可以调用该对象的如下三个方法来访问Annotation信息：<br><br>getAnnotation(Class<T> annotationClass);  //返回该程序元素上存在的、指定类型的注释，如果该类型的注释不存在，则返回null。<br><br>Annotation[] getAnnotations();      //返回该程序元素上存在的所有注释。<br><br>boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass);      //判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false。<br></p>
<pre>
//@Retention注解指定GetLog注解保留多久
@Retention(RetentionPolicy.RUNTIME)
//@Target注解指定注解能修饰的目标(只能是方法)
@Target(ElementType.METHOD)
public @interface GetLog {
    String description() default "${description}";
}
<pre>

定义Annotation时使用了<span style="color:red">@Retention</span>和<span style="color:red">@Target</span>两个系统元注释，其中@Retention注释指定Test注释可以保留多久，@Target注释指定Test注释能修饰的目标（）.<br>
仅仅使用注释来标识程序元素对程序是不会有任何影响的，这也是Java注释的一条重要原则。<br>
<span style="color:red">@Retention</span>
@Retention只能用于修饰一个Annotation定义，用于指定该Annotation可以保留多长时间，@Retention包含一个RetentionPolicy类型的value成员变量，所以使用@Retention时必须为该value成员变量指定值。
value成员变量的值只能是如下三个：
RetentionPolicy.CLASS: 编译器将把注释记录在class文件中。当运行Java程序时，JVM不在保留注释，这是默认值。
RetentionPolicy.RUNTIME: 编译器将把注释记录在class文件中。当运行Java程序时，JVM也会保留注释，程序可以通过反射获取该注释。
RetentionPolicy.SOURCE:  注解仅存在于源码中，在class字节码文件中不包含。
<span style="color:red">@Target</span>
@Target也是用于修饰一个Annotation定义，它用于指定被修饰Annotation能用于修饰那些程序元素。@Target Annotation也包含一个名为value的成员变量，该成员变量只能是如下几个：<br>
ElementType.ANNOTATION_TYPE: 指定该策略的Annotation只能修饰Annotation。
ElementType.CONSTRUCTOR:  指定该策略的Annotation能修饰构造器。
ElementType.FIELD:  指定该策略的Annotation只能修饰成员变量。
ElementType.LOCAL_VARIABLE:  指定该策略的Annotation只能修饰局部变量。
ElementType.METHOD: 指定该策略的Annotation只能修饰方法。
ElementType.PACKAGE:  指定该策略的Annotation只能修饰包定义。
ElementType.PARAMETER:  指定该策略的Annotation可以修饰参数。
ElementType.TYPE:  指定该策略的Annotation可以修饰类、接口（包括注释类型）或枚举定义。
<span style="color:red">@Documented</span>
@Documented用于指定该元Annotation修饰的Annotation类将被javadoc工具提取成文档，如果定义Annotation类时使用了@Documented修饰，则所有使用该Annotation修饰的程序元素的API文档中将会包含该Annotation说明。<br>
<span style="color:red">@Inherited</span>
@Inherited 元 Annotation指定被它修饰的Annotation将具有继承性：如果某个类使用了A Annotation（定义该Annotation时使用了@Inherited修饰）修饰，则其子类将自动具有A注释.

### AOP

### 动态代理

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/20/java/cron_java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohua Dong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="隔壁董小花同学">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/20/java/cron_java/" itemprop="url">cron基础用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-20T19:01:08+08:00">
                2018-07-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在线Cron表达式生成器 : <a href="http://cron.qqe2.com/" target="_blank" rel="noopener">http://cron.qqe2.com/</a></p>
<p>（1）<span style="color:red">*</span>：表示匹配该域的任意值。假如在Minutes域使用<em>, 即表示每分钟都会触发事件。<br>（2）<span style="color:red">?</span>：只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 * ?, 其中最后一位只能用？，而不能使用</em>，如果使用*表示不管星期几都会触发，实际上并不是这样。<br>（3）<span style="color:red">-</span>：表示范围。例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次<br>（4）<span style="color:red">/</span>：表示起始时间开始触发，然后每隔固定时间触发一次。例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次.<br>（5）<span style="color:red">,</span>：表示列出枚举值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。<br>（6）<span style="color:red">L</span>：表示最后，只能出现在DayofWeek和DayofMonth域。如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。<br>（7）<span style="color:red">W</span>:表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 。<br>（8）<span style="color:red">LW</span>:这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。<br>（9）<span style="color:red">#</span> :用于确定每个月第几个星期几，只能出现在DayofMonth域。例如在4#2，表示某月的第二个星期三。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">xiaohua Dong</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xiaohua Dong</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
